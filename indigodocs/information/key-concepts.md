---
id: key-concepts
title: Key Concepts
---

## Making a game testable

If you want to be able to test a frame of a game, a whole frame, then you need one thing: Referential transparency.

Referential transparency allows you to ask for the next frame of a game, and compare it to an expected value, confident that they will always always be equivalent, provided your expected value is correct.

The problem is that games are random, time sensitive, and usually use mutable state for better performance.

Some of he key things that Indigo gives you then:

1. Known time - each frame's logic gets one time value regardless of how long it takes to process the frame.
2. Psuedo randomness - seeded from the game's running time, but you can always find out what "random" values were used.
3. Immutability - the state and all inputs to a frame are immutable, leading to consistent results.
4. Side effect free*, Declaritive API's - since your state is immutable, you must describe what you'd like to happen next, rather than being able to directly action it now, all but eliminating race conditions.
5. Predictable scene composition - `SceneUpdateFragment`s are combined very simply allowing you to test the view description in an ordinary unit test.

>*One exception... bounds calculations can be very expensive and currently are sometimes cached for performance reasons. It's an area under active consideration.

## "Your whole game, as a single, pure, stateless function."

The default interfaces you're presented with as part of Indigo's framework offer a range of functions and values that you need to decide how to implement, but that is all just to improve the user experience.

Beneath the API is a single function that looks something like this:

```scala
def run(
      model: Model,
      viewModel: ViewModel,
      gameTime: GameTime,
      globalEvents: List[GlobalEvent],
      inputState: InputState,
      dice: Dice,
      boundaryLocator: BoundaryLocator
  ): Outcome[(Model, ViewModel, SceneUpdateFragment)]
```

>Please note that game time, global events, input states, dice and the boundary locator are wrapped up in the `FrameContext` on the standard Indigo APIs.

The point of this function is purity.

Games in other engines are pretty hard to reason about, in that it is difficult to know what is going to happen between one frame and the next, and that makes writing tests for games equally tricky.

Indigo is about making games fun to build for functional programmers. Caring more about _developer performance_ than _engine performance_. Yes that's right, you heard it here first, there are faster more performant engines out there! Instead, Indigo is designed to give the developer a high degree of confidence in their code. All the power of Scala's type system, backed up by a framework you can write tests for, and a life cycle you can predict.

##Â Inputs are immutable and predicatable

It will come as no surprise to Scala functional programmers, but all of the inputs to the run function above are immutable. You can access them and read from them but you can't change them. This eliminates a whole class of errors around race conditions during frame evaluation.

Walking through them one at a time:

- `model: Model` - This is the read-only state of the model, as caculated by the previous frame (or the initial state).
- `viewModel: ViewModel` - This is the read-only state of the view-model, as caculated by the previous frame (or the initial state).
- `gameTime: GameTime` - Time information such as frame deltas, all based on the current running time of your game.
- `globalEvents: List[GlobalEvent]` - `GlobalEvents` only last for one frame, and can only be accessed in the next frame. This list then, is all* of the events generated by the previous frame.
- `inputState: InputState` - Created from the GlobalEvents list, and represents what is going on with the keyboard, mouse and gamepad.
- `dice: Dice` - Psuedo random elements can be added using the provided `Dice` instance, which is seeded from the game's running time. (Warning: Dice start at 1, not 0, don't they...)
- `boundaryLocator: BoundaryLocator` - A service that can be used to find the boundaries of scene elements.

> *With the exception that some events, intended to instruct Indigo itself to do something, will not be available to the next frame. For example an emitted `PlaySound` event will be delivered to the Audio system, but not to the next frame.

## Outputs are monoidal

Some clarification, the return type of the function above is:

```scala
Outcome[(Model, ViewModel, SceneUpdateFragment)]
```

But it's easier to think of this as:

1. An updated model
1. An updated view model
1. A new scene to draw (`SceneUpdateFragment`)
1. A list of events to be processed and passed to the relevant systems or the next frame. (`List[GlobalEvent]`)

The model and view model are defined by the game developer and are therefore not assumed to be monoidal, they are simply recorded and passed as input to the next frame.

The `SceneUpdateFragment` and `List[GlobalEvent]` however are monoidal i.e. they have an identity value and can be combined following all the appropriate rules.

This has the incredibilibly useful property that you don't need to describe your frame's results (graph and events) all in one go. You can defined them in little modules (such as Indigo's `SubSystem`s) and be sure that indigo will combine them predictably and testably when the game is run.
