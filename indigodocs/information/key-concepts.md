---
id: key-concepts
title: Key Concepts
---

## "Your whole game, as a single, pure, stateless function."

The default interfaces you're presented with as part of Indigo's framework offer a range of functions and values that you need to decide how to implement, but that is all just UX.

Beneath the API is a single function, that looks like this:

```scala
def run(
      model: Model,
      viewModel: ViewModel,
      gameTime: GameTime,
      globalEvents: List[GlobalEvent],
      inputState: InputState,
      dice: Dice,
      boundaryLocator: BoundaryLocator
  ): Outcome[(Model, ViewModel, SceneUpdateFragment)]
```

The point of this function, is purity. Games in other engines are hard to reason about. It's difficult to know what is going to happen between one frame and the next, and that makes writing tests for games very difficult.

Indigo is about making games fun to build for functional programmers. Caring more about _developer performance_ than _engine performance_. Indigo is designed to give the developer a high degree of confidence in their code. All the power of Scala's type system, backed up by a framework you can write tests for, and a life cycle you can predict.

##Â Inputs are immutable and predicatable

It will come as no surprise to Scala functional programmers, but all of the inputs to the run function above are immutable. You can access them and read from them but you can't change them. This eliminates a whole class of errors around race conditions during frame evaluation.

Walking through them one at a time:

- `model: Model` - This is the read-only state of the model, as caculated by the previous frame (or the initial state).
- `viewModel: ViewModel` - This is the read-only state of the view-model, as caculated by the previous frame (or the initial state).
- `gameTime: GameTime` - Time information such as frame deltas, all based on the current running time of your game.
- `globalEvents: List[GlobalEvent]` - `GlobalEvents` only last for one frame, and can only be accessed in the subsequent frame. This list is all* of the events generated by the previous frame.
- `inputState: InputState` - Created from the GlobalEvents list, and represents what is going on with the keyboard, mouse and gamepad.
- `dice: Dice` - Psuedo random elements can be added using the provided `Dice` instance, which is seeded from the game's running time.
- `boundaryLocator: BoundaryLocator` - A service that can be used to find the boundaries of scene elements.

> *With the exception that events intended to instruct Indigo itself to do something will not be available to the next frame. For example an emitted `PlaySound` event will be delivered to the Audio system, but not to the next frame.

## Outputs are monoidal

Some clarification, the return type of the function above is:

```scala
Outcome[(Model, ViewModel, SceneUpdateFragment)]
```

But it's easier to think of this as:

1. An updated model
1. An updated view model
1. A new scene to draw (`SceneUpdateFragment`)
1. A list of events to be processed and passed to the relevant systems or the next frame. (`List[GlobalEvent]`)

The model and view model are defined by the game developer and are not assumed to be monoidal, they're simply recorded and passed as input to the next frame.

The `SceneUpdateFragment` and `List[GlobalEvent]` however are monoidal i.e. they have an identity value and can be combined following all the appropriate rules.

This has the incredibilibly useful property that you don't need to describe your frame's results (graph and events) all in one go. You can defined them in little modules (such as Indigo's `SubSystem`s) and be sure that indigo will combine them predictably and testably.
